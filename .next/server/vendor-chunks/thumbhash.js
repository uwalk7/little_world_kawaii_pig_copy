"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/thumbhash";
exports.ids = ["vendor-chunks/thumbhash"];
exports.modules = {

/***/ "(rsc)/./node_modules/thumbhash/thumbhash.js":
/*!*********************************************!*\
  !*** ./node_modules/thumbhash/thumbhash.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rgbaToDataURL: () => (/* binding */ rgbaToDataURL),\n/* harmony export */   rgbaToThumbHash: () => (/* binding */ rgbaToThumbHash),\n/* harmony export */   thumbHashToApproximateAspectRatio: () => (/* binding */ thumbHashToApproximateAspectRatio),\n/* harmony export */   thumbHashToAverageRGBA: () => (/* binding */ thumbHashToAverageRGBA),\n/* harmony export */   thumbHashToDataURL: () => (/* binding */ thumbHashToDataURL),\n/* harmony export */   thumbHashToRGBA: () => (/* binding */ thumbHashToRGBA)\n/* harmony export */ });\n/**\n * Encodes an RGBA image to a ThumbHash. RGB should not be premultiplied by A.\n *\n * @param w The width of the input image. Must be ≤100px.\n * @param h The height of the input image. Must be ≤100px.\n * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.\n * @returns The ThumbHash as a Uint8Array.\n */\nfunction rgbaToThumbHash(w, h, rgba) {\n  // Encoding an image larger than 100x100 is slow with no benefit\n  if (w > 100 || h > 100) throw new Error(`${w}x${h} doesn't fit in 100x100`)\n  let { PI, round, max, cos, abs } = Math\n\n  // Determine the average color\n  let avg_r = 0, avg_g = 0, avg_b = 0, avg_a = 0\n  for (let i = 0, j = 0; i < w * h; i++, j += 4) {\n    let alpha = rgba[j + 3] / 255\n    avg_r += alpha / 255 * rgba[j]\n    avg_g += alpha / 255 * rgba[j + 1]\n    avg_b += alpha / 255 * rgba[j + 2]\n    avg_a += alpha\n  }\n  if (avg_a) {\n    avg_r /= avg_a\n    avg_g /= avg_a\n    avg_b /= avg_a\n  }\n\n  let hasAlpha = avg_a < w * h\n  let l_limit = hasAlpha ? 5 : 7 // Use fewer luminance bits if there's alpha\n  let lx = max(1, round(l_limit * w / max(w, h)))\n  let ly = max(1, round(l_limit * h / max(w, h)))\n  let l = [] // luminance\n  let p = [] // yellow - blue\n  let q = [] // red - green\n  let a = [] // alpha\n\n  // Convert the image from RGBA to LPQA (composite atop the average color)\n  for (let i = 0, j = 0; i < w * h; i++, j += 4) {\n    let alpha = rgba[j + 3] / 255\n    let r = avg_r * (1 - alpha) + alpha / 255 * rgba[j]\n    let g = avg_g * (1 - alpha) + alpha / 255 * rgba[j + 1]\n    let b = avg_b * (1 - alpha) + alpha / 255 * rgba[j + 2]\n    l[i] = (r + g + b) / 3\n    p[i] = (r + g) / 2 - b\n    q[i] = r - g\n    a[i] = alpha\n  }\n\n  // Encode using the DCT into DC (constant) and normalized AC (varying) terms\n  let encodeChannel = (channel, nx, ny) => {\n    let dc = 0, ac = [], scale = 0, fx = []\n    for (let cy = 0; cy < ny; cy++) {\n      for (let cx = 0; cx * ny < nx * (ny - cy); cx++) {\n        let f = 0\n        for (let x = 0; x < w; x++)\n          fx[x] = cos(PI / w * cx * (x + 0.5))\n        for (let y = 0; y < h; y++)\n          for (let x = 0, fy = cos(PI / h * cy * (y + 0.5)); x < w; x++)\n            f += channel[x + y * w] * fx[x] * fy\n        f /= w * h\n        if (cx || cy) {\n          ac.push(f)\n          scale = max(scale, abs(f))\n        } else {\n          dc = f\n        }\n      }\n    }\n    if (scale)\n      for (let i = 0; i < ac.length; i++)\n        ac[i] = 0.5 + 0.5 / scale * ac[i]\n    return [dc, ac, scale]\n  }\n  let [l_dc, l_ac, l_scale] = encodeChannel(l, max(3, lx), max(3, ly))\n  let [p_dc, p_ac, p_scale] = encodeChannel(p, 3, 3)\n  let [q_dc, q_ac, q_scale] = encodeChannel(q, 3, 3)\n  let [a_dc, a_ac, a_scale] = hasAlpha ? encodeChannel(a, 5, 5) : []\n\n  // Write the constants\n  let isLandscape = w > h\n  let header24 = round(63 * l_dc) | (round(31.5 + 31.5 * p_dc) << 6) | (round(31.5 + 31.5 * q_dc) << 12) | (round(31 * l_scale) << 18) | (hasAlpha << 23)\n  let header16 = (isLandscape ? ly : lx) | (round(63 * p_scale) << 3) | (round(63 * q_scale) << 9) | (isLandscape << 15)\n  let hash = [header24 & 255, (header24 >> 8) & 255, header24 >> 16, header16 & 255, header16 >> 8]\n  let ac_start = hasAlpha ? 6 : 5\n  let ac_index = 0\n  if (hasAlpha) hash.push(round(15 * a_dc) | (round(15 * a_scale) << 4))\n\n  // Write the varying factors\n  for (let ac of hasAlpha ? [l_ac, p_ac, q_ac, a_ac] : [l_ac, p_ac, q_ac])\n    for (let f of ac)\n      hash[ac_start + (ac_index >> 1)] |= round(15 * f) << ((ac_index++ & 1) << 2)\n  return new Uint8Array(hash)\n}\n\n/**\n * Decodes a ThumbHash to an RGBA image. RGB is not be premultiplied by A.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The width, height, and pixels of the rendered placeholder image.\n */\nfunction thumbHashToRGBA(hash) {\n  let { PI, min, max, cos, round } = Math\n\n  // Read the constants\n  let header24 = hash[0] | (hash[1] << 8) | (hash[2] << 16)\n  let header16 = hash[3] | (hash[4] << 8)\n  let l_dc = (header24 & 63) / 63\n  let p_dc = ((header24 >> 6) & 63) / 31.5 - 1\n  let q_dc = ((header24 >> 12) & 63) / 31.5 - 1\n  let l_scale = ((header24 >> 18) & 31) / 31\n  let hasAlpha = header24 >> 23\n  let p_scale = ((header16 >> 3) & 63) / 63\n  let q_scale = ((header16 >> 9) & 63) / 63\n  let isLandscape = header16 >> 15\n  let lx = max(3, isLandscape ? hasAlpha ? 5 : 7 : header16 & 7)\n  let ly = max(3, isLandscape ? header16 & 7 : hasAlpha ? 5 : 7)\n  let a_dc = hasAlpha ? (hash[5] & 15) / 15 : 1\n  let a_scale = (hash[5] >> 4) / 15\n\n  // Read the varying factors (boost saturation by 1.25x to compensate for quantization)\n  let ac_start = hasAlpha ? 6 : 5\n  let ac_index = 0\n  let decodeChannel = (nx, ny, scale) => {\n    let ac = []\n    for (let cy = 0; cy < ny; cy++)\n      for (let cx = cy ? 0 : 1; cx * ny < nx * (ny - cy); cx++)\n        ac.push((((hash[ac_start + (ac_index >> 1)] >> ((ac_index++ & 1) << 2)) & 15) / 7.5 - 1) * scale)\n    return ac\n  }\n  let l_ac = decodeChannel(lx, ly, l_scale)\n  let p_ac = decodeChannel(3, 3, p_scale * 1.25)\n  let q_ac = decodeChannel(3, 3, q_scale * 1.25)\n  let a_ac = hasAlpha && decodeChannel(5, 5, a_scale)\n\n  // Decode using the DCT into RGB\n  let ratio = thumbHashToApproximateAspectRatio(hash)\n  let w = round(ratio > 1 ? 32 : 32 * ratio)\n  let h = round(ratio > 1 ? 32 / ratio : 32)\n  let rgba = new Uint8Array(w * h * 4), fx = [], fy = []\n  for (let y = 0, i = 0; y < h; y++) {\n    for (let x = 0; x < w; x++, i += 4) {\n      let l = l_dc, p = p_dc, q = q_dc, a = a_dc\n\n      // Precompute the coefficients\n      for (let cx = 0, n = max(lx, hasAlpha ? 5 : 3); cx < n; cx++)\n        fx[cx] = cos(PI / w * (x + 0.5) * cx)\n      for (let cy = 0, n = max(ly, hasAlpha ? 5 : 3); cy < n; cy++)\n        fy[cy] = cos(PI / h * (y + 0.5) * cy)\n\n      // Decode L\n      for (let cy = 0, j = 0; cy < ly; cy++)\n        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx * ly < lx * (ly - cy); cx++, j++)\n          l += l_ac[j] * fx[cx] * fy2\n\n      // Decode P and Q\n      for (let cy = 0, j = 0; cy < 3; cy++) {\n        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 3 - cy; cx++, j++) {\n          let f = fx[cx] * fy2\n          p += p_ac[j] * f\n          q += q_ac[j] * f\n        }\n      }\n\n      // Decode A\n      if (hasAlpha)\n        for (let cy = 0, j = 0; cy < 5; cy++)\n          for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 5 - cy; cx++, j++)\n            a += a_ac[j] * fx[cx] * fy2\n\n      // Convert to RGB\n      let b = l - 2 / 3 * p\n      let r = (3 * l - b + q) / 2\n      let g = r - q\n      rgba[i] = max(0, 255 * min(1, r))\n      rgba[i + 1] = max(0, 255 * min(1, g))\n      rgba[i + 2] = max(0, 255 * min(1, b))\n      rgba[i + 3] = max(0, 255 * min(1, a))\n    }\n  }\n  return { w, h, rgba }\n}\n\n/**\n * Extracts the average color from a ThumbHash. RGB is not be premultiplied by A.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The RGBA values for the average color. Each value ranges from 0 to 1.\n */\nfunction thumbHashToAverageRGBA(hash) {\n  let { min, max } = Math\n  let header = hash[0] | (hash[1] << 8) | (hash[2] << 16)\n  let l = (header & 63) / 63\n  let p = ((header >> 6) & 63) / 31.5 - 1\n  let q = ((header >> 12) & 63) / 31.5 - 1\n  let hasAlpha = header >> 23\n  let a = hasAlpha ? (hash[5] & 15) / 15 : 1\n  let b = l - 2 / 3 * p\n  let r = (3 * l - b + q) / 2\n  let g = r - q\n  return {\n    r: max(0, min(1, r)),\n    g: max(0, min(1, g)),\n    b: max(0, min(1, b)),\n    a\n  }\n}\n\n/**\n * Extracts the approximate aspect ratio of the original image.\n *\n * @param hash The bytes of the ThumbHash.\n * @returns The approximate aspect ratio (i.e. width / height).\n */\nfunction thumbHashToApproximateAspectRatio(hash) {\n  let header = hash[3]\n  let hasAlpha = hash[2] & 0x80\n  let isLandscape = hash[4] & 0x80\n  let lx = isLandscape ? hasAlpha ? 5 : 7 : header & 7\n  let ly = isLandscape ? header & 7 : hasAlpha ? 5 : 7\n  return lx / ly\n}\n\n/**\n * Encodes an RGBA image to a PNG data URL. RGB should not be premultiplied by\n * A. This is optimized for speed and simplicity and does not optimize for size\n * at all. This doesn't do any compression (all values are stored uncompressed).\n *\n * @param w The width of the input image. Must be ≤100px.\n * @param h The height of the input image. Must be ≤100px.\n * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.\n * @returns A data URL containing a PNG for the input image.\n */\nfunction rgbaToDataURL(w, h, rgba) {\n  let row = w * 4 + 1\n  let idat = 6 + h * (5 + row)\n  let bytes = [\n    137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0,\n    w >> 8, w & 255, 0, 0, h >> 8, h & 255, 8, 6, 0, 0, 0, 0, 0, 0, 0,\n    idat >>> 24, (idat >> 16) & 255, (idat >> 8) & 255, idat & 255,\n    73, 68, 65, 84, 120, 1\n  ]\n  let table = [\n    0, 498536548, 997073096, 651767980, 1994146192, 1802195444, 1303535960,\n    1342533948, -306674912, -267414716, -690576408, -882789492, -1687895376,\n    -2032938284, -1609899400, -1111625188\n  ]\n  let a = 1, b = 0\n  for (let y = 0, i = 0, end = row - 1; y < h; y++, end += row - 1) {\n    bytes.push(y + 1 < h ? 0 : 1, row & 255, row >> 8, ~row & 255, (row >> 8) ^ 255, 0)\n    for (b = (b + a) % 65521; i < end; i++) {\n      let u = rgba[i] & 255\n      bytes.push(u)\n      a = (a + u) % 65521\n      b = (b + a) % 65521\n    }\n  }\n  bytes.push(\n    b >> 8, b & 255, a >> 8, a & 255, 0, 0, 0, 0,\n    0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130\n  )\n  for (let [start, end] of [[12, 29], [37, 41 + idat]]) {\n    let c = ~0\n    for (let i = start; i < end; i++) {\n      c ^= bytes[i]\n      c = (c >>> 4) ^ table[c & 15]\n      c = (c >>> 4) ^ table[c & 15]\n    }\n    c = ~c\n    bytes[end++] = c >>> 24\n    bytes[end++] = (c >> 16) & 255\n    bytes[end++] = (c >> 8) & 255\n    bytes[end++] = c & 255\n  }\n  return 'data:image/png;base64,' + btoa(String.fromCharCode(...bytes))\n}\n\n/**\n * Decodes a ThumbHash to a PNG data URL. This is a convenience function that\n * just calls \"thumbHashToRGBA\" followed by \"rgbaToDataURL\".\n *\n * @param hash The bytes of the ThumbHash.\n * @returns A data URL containing a PNG for the rendered ThumbHash.\n */\nfunction thumbHashToDataURL(hash) {\n  let image = thumbHashToRGBA(hash)\n  return rgbaToDataURL(image.w, image.h, image.rgba)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGh1bWJoYXNoL3RodW1iaGFzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDZDQUE2QyxFQUFFLEdBQUcsR0FBRztBQUNyRCxRQUFRLDJCQUEyQjs7QUFFbkM7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5Qix1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQiw2REFBNkQsT0FBTztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsMkJBQTJCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCLGdDQUFnQywwQkFBMEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDLG9CQUFvQixPQUFPO0FBQzNCOztBQUVBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDs7QUFFQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDLG9EQUFvRCwwQkFBMEI7QUFDOUU7O0FBRUE7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QyxvREFBb0QsYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QyxzREFBc0QsYUFBYTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG1hcnRvXFxEb3dubG9hZHNcXGxpdHRsZV93b3JsZF9rYXdhaWlfcGlnX2NvcHlcXG5vZGVfbW9kdWxlc1xcdGh1bWJoYXNoXFx0aHVtYmhhc2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFbmNvZGVzIGFuIFJHQkEgaW1hZ2UgdG8gYSBUaHVtYkhhc2guIFJHQiBzaG91bGQgbm90IGJlIHByZW11bHRpcGxpZWQgYnkgQS5cbiAqXG4gKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIGlucHV0IGltYWdlLiBNdXN0IGJlIOKJpDEwMHB4LlxuICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgaW1hZ2UuIE11c3QgYmUg4omkMTAwcHguXG4gKiBAcGFyYW0gcmdiYSBUaGUgcGl4ZWxzIGluIHRoZSBpbnB1dCBpbWFnZSwgcm93LWJ5LXJvdy4gTXVzdCBoYXZlIHcqaCo0IGVsZW1lbnRzLlxuICogQHJldHVybnMgVGhlIFRodW1iSGFzaCBhcyBhIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZ2JhVG9UaHVtYkhhc2godywgaCwgcmdiYSkge1xuICAvLyBFbmNvZGluZyBhbiBpbWFnZSBsYXJnZXIgdGhhbiAxMDB4MTAwIGlzIHNsb3cgd2l0aCBubyBiZW5lZml0XG4gIGlmICh3ID4gMTAwIHx8IGggPiAxMDApIHRocm93IG5ldyBFcnJvcihgJHt3fXgke2h9IGRvZXNuJ3QgZml0IGluIDEwMHgxMDBgKVxuICBsZXQgeyBQSSwgcm91bmQsIG1heCwgY29zLCBhYnMgfSA9IE1hdGhcblxuICAvLyBEZXRlcm1pbmUgdGhlIGF2ZXJhZ2UgY29sb3JcbiAgbGV0IGF2Z19yID0gMCwgYXZnX2cgPSAwLCBhdmdfYiA9IDAsIGF2Z19hID0gMFxuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB3ICogaDsgaSsrLCBqICs9IDQpIHtcbiAgICBsZXQgYWxwaGEgPSByZ2JhW2ogKyAzXSAvIDI1NVxuICAgIGF2Z19yICs9IGFscGhhIC8gMjU1ICogcmdiYVtqXVxuICAgIGF2Z19nICs9IGFscGhhIC8gMjU1ICogcmdiYVtqICsgMV1cbiAgICBhdmdfYiArPSBhbHBoYSAvIDI1NSAqIHJnYmFbaiArIDJdXG4gICAgYXZnX2EgKz0gYWxwaGFcbiAgfVxuICBpZiAoYXZnX2EpIHtcbiAgICBhdmdfciAvPSBhdmdfYVxuICAgIGF2Z19nIC89IGF2Z19hXG4gICAgYXZnX2IgLz0gYXZnX2FcbiAgfVxuXG4gIGxldCBoYXNBbHBoYSA9IGF2Z19hIDwgdyAqIGhcbiAgbGV0IGxfbGltaXQgPSBoYXNBbHBoYSA/IDUgOiA3IC8vIFVzZSBmZXdlciBsdW1pbmFuY2UgYml0cyBpZiB0aGVyZSdzIGFscGhhXG4gIGxldCBseCA9IG1heCgxLCByb3VuZChsX2xpbWl0ICogdyAvIG1heCh3LCBoKSkpXG4gIGxldCBseSA9IG1heCgxLCByb3VuZChsX2xpbWl0ICogaCAvIG1heCh3LCBoKSkpXG4gIGxldCBsID0gW10gLy8gbHVtaW5hbmNlXG4gIGxldCBwID0gW10gLy8geWVsbG93IC0gYmx1ZVxuICBsZXQgcSA9IFtdIC8vIHJlZCAtIGdyZWVuXG4gIGxldCBhID0gW10gLy8gYWxwaGFcblxuICAvLyBDb252ZXJ0IHRoZSBpbWFnZSBmcm9tIFJHQkEgdG8gTFBRQSAoY29tcG9zaXRlIGF0b3AgdGhlIGF2ZXJhZ2UgY29sb3IpXG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHcgKiBoOyBpKyssIGogKz0gNCkge1xuICAgIGxldCBhbHBoYSA9IHJnYmFbaiArIDNdIC8gMjU1XG4gICAgbGV0IHIgPSBhdmdfciAqICgxIC0gYWxwaGEpICsgYWxwaGEgLyAyNTUgKiByZ2JhW2pdXG4gICAgbGV0IGcgPSBhdmdfZyAqICgxIC0gYWxwaGEpICsgYWxwaGEgLyAyNTUgKiByZ2JhW2ogKyAxXVxuICAgIGxldCBiID0gYXZnX2IgKiAoMSAtIGFscGhhKSArIGFscGhhIC8gMjU1ICogcmdiYVtqICsgMl1cbiAgICBsW2ldID0gKHIgKyBnICsgYikgLyAzXG4gICAgcFtpXSA9IChyICsgZykgLyAyIC0gYlxuICAgIHFbaV0gPSByIC0gZ1xuICAgIGFbaV0gPSBhbHBoYVxuICB9XG5cbiAgLy8gRW5jb2RlIHVzaW5nIHRoZSBEQ1QgaW50byBEQyAoY29uc3RhbnQpIGFuZCBub3JtYWxpemVkIEFDICh2YXJ5aW5nKSB0ZXJtc1xuICBsZXQgZW5jb2RlQ2hhbm5lbCA9IChjaGFubmVsLCBueCwgbnkpID0+IHtcbiAgICBsZXQgZGMgPSAwLCBhYyA9IFtdLCBzY2FsZSA9IDAsIGZ4ID0gW11cbiAgICBmb3IgKGxldCBjeSA9IDA7IGN5IDwgbnk7IGN5KyspIHtcbiAgICAgIGZvciAobGV0IGN4ID0gMDsgY3ggKiBueSA8IG54ICogKG55IC0gY3kpOyBjeCsrKSB7XG4gICAgICAgIGxldCBmID0gMFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHc7IHgrKylcbiAgICAgICAgICBmeFt4XSA9IGNvcyhQSSAvIHcgKiBjeCAqICh4ICsgMC41KSlcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoOyB5KyspXG4gICAgICAgICAgZm9yIChsZXQgeCA9IDAsIGZ5ID0gY29zKFBJIC8gaCAqIGN5ICogKHkgKyAwLjUpKTsgeCA8IHc7IHgrKylcbiAgICAgICAgICAgIGYgKz0gY2hhbm5lbFt4ICsgeSAqIHddICogZnhbeF0gKiBmeVxuICAgICAgICBmIC89IHcgKiBoXG4gICAgICAgIGlmIChjeCB8fCBjeSkge1xuICAgICAgICAgIGFjLnB1c2goZilcbiAgICAgICAgICBzY2FsZSA9IG1heChzY2FsZSwgYWJzKGYpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRjID0gZlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzY2FsZSlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWMubGVuZ3RoOyBpKyspXG4gICAgICAgIGFjW2ldID0gMC41ICsgMC41IC8gc2NhbGUgKiBhY1tpXVxuICAgIHJldHVybiBbZGMsIGFjLCBzY2FsZV1cbiAgfVxuICBsZXQgW2xfZGMsIGxfYWMsIGxfc2NhbGVdID0gZW5jb2RlQ2hhbm5lbChsLCBtYXgoMywgbHgpLCBtYXgoMywgbHkpKVxuICBsZXQgW3BfZGMsIHBfYWMsIHBfc2NhbGVdID0gZW5jb2RlQ2hhbm5lbChwLCAzLCAzKVxuICBsZXQgW3FfZGMsIHFfYWMsIHFfc2NhbGVdID0gZW5jb2RlQ2hhbm5lbChxLCAzLCAzKVxuICBsZXQgW2FfZGMsIGFfYWMsIGFfc2NhbGVdID0gaGFzQWxwaGEgPyBlbmNvZGVDaGFubmVsKGEsIDUsIDUpIDogW11cblxuICAvLyBXcml0ZSB0aGUgY29uc3RhbnRzXG4gIGxldCBpc0xhbmRzY2FwZSA9IHcgPiBoXG4gIGxldCBoZWFkZXIyNCA9IHJvdW5kKDYzICogbF9kYykgfCAocm91bmQoMzEuNSArIDMxLjUgKiBwX2RjKSA8PCA2KSB8IChyb3VuZCgzMS41ICsgMzEuNSAqIHFfZGMpIDw8IDEyKSB8IChyb3VuZCgzMSAqIGxfc2NhbGUpIDw8IDE4KSB8IChoYXNBbHBoYSA8PCAyMylcbiAgbGV0IGhlYWRlcjE2ID0gKGlzTGFuZHNjYXBlID8gbHkgOiBseCkgfCAocm91bmQoNjMgKiBwX3NjYWxlKSA8PCAzKSB8IChyb3VuZCg2MyAqIHFfc2NhbGUpIDw8IDkpIHwgKGlzTGFuZHNjYXBlIDw8IDE1KVxuICBsZXQgaGFzaCA9IFtoZWFkZXIyNCAmIDI1NSwgKGhlYWRlcjI0ID4+IDgpICYgMjU1LCBoZWFkZXIyNCA+PiAxNiwgaGVhZGVyMTYgJiAyNTUsIGhlYWRlcjE2ID4+IDhdXG4gIGxldCBhY19zdGFydCA9IGhhc0FscGhhID8gNiA6IDVcbiAgbGV0IGFjX2luZGV4ID0gMFxuICBpZiAoaGFzQWxwaGEpIGhhc2gucHVzaChyb3VuZCgxNSAqIGFfZGMpIHwgKHJvdW5kKDE1ICogYV9zY2FsZSkgPDwgNCkpXG5cbiAgLy8gV3JpdGUgdGhlIHZhcnlpbmcgZmFjdG9yc1xuICBmb3IgKGxldCBhYyBvZiBoYXNBbHBoYSA/IFtsX2FjLCBwX2FjLCBxX2FjLCBhX2FjXSA6IFtsX2FjLCBwX2FjLCBxX2FjXSlcbiAgICBmb3IgKGxldCBmIG9mIGFjKVxuICAgICAgaGFzaFthY19zdGFydCArIChhY19pbmRleCA+PiAxKV0gfD0gcm91bmQoMTUgKiBmKSA8PCAoKGFjX2luZGV4KysgJiAxKSA8PCAyKVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGFzaClcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgVGh1bWJIYXNoIHRvIGFuIFJHQkEgaW1hZ2UuIFJHQiBpcyBub3QgYmUgcHJlbXVsdGlwbGllZCBieSBBLlxuICpcbiAqIEBwYXJhbSBoYXNoIFRoZSBieXRlcyBvZiB0aGUgVGh1bWJIYXNoLlxuICogQHJldHVybnMgVGhlIHdpZHRoLCBoZWlnaHQsIGFuZCBwaXhlbHMgb2YgdGhlIHJlbmRlcmVkIHBsYWNlaG9sZGVyIGltYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGh1bWJIYXNoVG9SR0JBKGhhc2gpIHtcbiAgbGV0IHsgUEksIG1pbiwgbWF4LCBjb3MsIHJvdW5kIH0gPSBNYXRoXG5cbiAgLy8gUmVhZCB0aGUgY29uc3RhbnRzXG4gIGxldCBoZWFkZXIyNCA9IGhhc2hbMF0gfCAoaGFzaFsxXSA8PCA4KSB8IChoYXNoWzJdIDw8IDE2KVxuICBsZXQgaGVhZGVyMTYgPSBoYXNoWzNdIHwgKGhhc2hbNF0gPDwgOClcbiAgbGV0IGxfZGMgPSAoaGVhZGVyMjQgJiA2MykgLyA2M1xuICBsZXQgcF9kYyA9ICgoaGVhZGVyMjQgPj4gNikgJiA2MykgLyAzMS41IC0gMVxuICBsZXQgcV9kYyA9ICgoaGVhZGVyMjQgPj4gMTIpICYgNjMpIC8gMzEuNSAtIDFcbiAgbGV0IGxfc2NhbGUgPSAoKGhlYWRlcjI0ID4+IDE4KSAmIDMxKSAvIDMxXG4gIGxldCBoYXNBbHBoYSA9IGhlYWRlcjI0ID4+IDIzXG4gIGxldCBwX3NjYWxlID0gKChoZWFkZXIxNiA+PiAzKSAmIDYzKSAvIDYzXG4gIGxldCBxX3NjYWxlID0gKChoZWFkZXIxNiA+PiA5KSAmIDYzKSAvIDYzXG4gIGxldCBpc0xhbmRzY2FwZSA9IGhlYWRlcjE2ID4+IDE1XG4gIGxldCBseCA9IG1heCgzLCBpc0xhbmRzY2FwZSA/IGhhc0FscGhhID8gNSA6IDcgOiBoZWFkZXIxNiAmIDcpXG4gIGxldCBseSA9IG1heCgzLCBpc0xhbmRzY2FwZSA/IGhlYWRlcjE2ICYgNyA6IGhhc0FscGhhID8gNSA6IDcpXG4gIGxldCBhX2RjID0gaGFzQWxwaGEgPyAoaGFzaFs1XSAmIDE1KSAvIDE1IDogMVxuICBsZXQgYV9zY2FsZSA9IChoYXNoWzVdID4+IDQpIC8gMTVcblxuICAvLyBSZWFkIHRoZSB2YXJ5aW5nIGZhY3RvcnMgKGJvb3N0IHNhdHVyYXRpb24gYnkgMS4yNXggdG8gY29tcGVuc2F0ZSBmb3IgcXVhbnRpemF0aW9uKVxuICBsZXQgYWNfc3RhcnQgPSBoYXNBbHBoYSA/IDYgOiA1XG4gIGxldCBhY19pbmRleCA9IDBcbiAgbGV0IGRlY29kZUNoYW5uZWwgPSAobngsIG55LCBzY2FsZSkgPT4ge1xuICAgIGxldCBhYyA9IFtdXG4gICAgZm9yIChsZXQgY3kgPSAwOyBjeSA8IG55OyBjeSsrKVxuICAgICAgZm9yIChsZXQgY3ggPSBjeSA/IDAgOiAxOyBjeCAqIG55IDwgbnggKiAobnkgLSBjeSk7IGN4KyspXG4gICAgICAgIGFjLnB1c2goKCgoaGFzaFthY19zdGFydCArIChhY19pbmRleCA+PiAxKV0gPj4gKChhY19pbmRleCsrICYgMSkgPDwgMikpICYgMTUpIC8gNy41IC0gMSkgKiBzY2FsZSlcbiAgICByZXR1cm4gYWNcbiAgfVxuICBsZXQgbF9hYyA9IGRlY29kZUNoYW5uZWwobHgsIGx5LCBsX3NjYWxlKVxuICBsZXQgcF9hYyA9IGRlY29kZUNoYW5uZWwoMywgMywgcF9zY2FsZSAqIDEuMjUpXG4gIGxldCBxX2FjID0gZGVjb2RlQ2hhbm5lbCgzLCAzLCBxX3NjYWxlICogMS4yNSlcbiAgbGV0IGFfYWMgPSBoYXNBbHBoYSAmJiBkZWNvZGVDaGFubmVsKDUsIDUsIGFfc2NhbGUpXG5cbiAgLy8gRGVjb2RlIHVzaW5nIHRoZSBEQ1QgaW50byBSR0JcbiAgbGV0IHJhdGlvID0gdGh1bWJIYXNoVG9BcHByb3hpbWF0ZUFzcGVjdFJhdGlvKGhhc2gpXG4gIGxldCB3ID0gcm91bmQocmF0aW8gPiAxID8gMzIgOiAzMiAqIHJhdGlvKVxuICBsZXQgaCA9IHJvdW5kKHJhdGlvID4gMSA/IDMyIC8gcmF0aW8gOiAzMilcbiAgbGV0IHJnYmEgPSBuZXcgVWludDhBcnJheSh3ICogaCAqIDQpLCBmeCA9IFtdLCBmeSA9IFtdXG4gIGZvciAobGV0IHkgPSAwLCBpID0gMDsgeSA8IGg7IHkrKykge1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgdzsgeCsrLCBpICs9IDQpIHtcbiAgICAgIGxldCBsID0gbF9kYywgcCA9IHBfZGMsIHEgPSBxX2RjLCBhID0gYV9kY1xuXG4gICAgICAvLyBQcmVjb21wdXRlIHRoZSBjb2VmZmljaWVudHNcbiAgICAgIGZvciAobGV0IGN4ID0gMCwgbiA9IG1heChseCwgaGFzQWxwaGEgPyA1IDogMyk7IGN4IDwgbjsgY3grKylcbiAgICAgICAgZnhbY3hdID0gY29zKFBJIC8gdyAqICh4ICsgMC41KSAqIGN4KVxuICAgICAgZm9yIChsZXQgY3kgPSAwLCBuID0gbWF4KGx5LCBoYXNBbHBoYSA/IDUgOiAzKTsgY3kgPCBuOyBjeSsrKVxuICAgICAgICBmeVtjeV0gPSBjb3MoUEkgLyBoICogKHkgKyAwLjUpICogY3kpXG5cbiAgICAgIC8vIERlY29kZSBMXG4gICAgICBmb3IgKGxldCBjeSA9IDAsIGogPSAwOyBjeSA8IGx5OyBjeSsrKVxuICAgICAgICBmb3IgKGxldCBjeCA9IGN5ID8gMCA6IDEsIGZ5MiA9IGZ5W2N5XSAqIDI7IGN4ICogbHkgPCBseCAqIChseSAtIGN5KTsgY3grKywgaisrKVxuICAgICAgICAgIGwgKz0gbF9hY1tqXSAqIGZ4W2N4XSAqIGZ5MlxuXG4gICAgICAvLyBEZWNvZGUgUCBhbmQgUVxuICAgICAgZm9yIChsZXQgY3kgPSAwLCBqID0gMDsgY3kgPCAzOyBjeSsrKSB7XG4gICAgICAgIGZvciAobGV0IGN4ID0gY3kgPyAwIDogMSwgZnkyID0gZnlbY3ldICogMjsgY3ggPCAzIC0gY3k7IGN4KyssIGorKykge1xuICAgICAgICAgIGxldCBmID0gZnhbY3hdICogZnkyXG4gICAgICAgICAgcCArPSBwX2FjW2pdICogZlxuICAgICAgICAgIHEgKz0gcV9hY1tqXSAqIGZcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEZWNvZGUgQVxuICAgICAgaWYgKGhhc0FscGhhKVxuICAgICAgICBmb3IgKGxldCBjeSA9IDAsIGogPSAwOyBjeSA8IDU7IGN5KyspXG4gICAgICAgICAgZm9yIChsZXQgY3ggPSBjeSA/IDAgOiAxLCBmeTIgPSBmeVtjeV0gKiAyOyBjeCA8IDUgLSBjeTsgY3grKywgaisrKVxuICAgICAgICAgICAgYSArPSBhX2FjW2pdICogZnhbY3hdICogZnkyXG5cbiAgICAgIC8vIENvbnZlcnQgdG8gUkdCXG4gICAgICBsZXQgYiA9IGwgLSAyIC8gMyAqIHBcbiAgICAgIGxldCByID0gKDMgKiBsIC0gYiArIHEpIC8gMlxuICAgICAgbGV0IGcgPSByIC0gcVxuICAgICAgcmdiYVtpXSA9IG1heCgwLCAyNTUgKiBtaW4oMSwgcikpXG4gICAgICByZ2JhW2kgKyAxXSA9IG1heCgwLCAyNTUgKiBtaW4oMSwgZykpXG4gICAgICByZ2JhW2kgKyAyXSA9IG1heCgwLCAyNTUgKiBtaW4oMSwgYikpXG4gICAgICByZ2JhW2kgKyAzXSA9IG1heCgwLCAyNTUgKiBtaW4oMSwgYSkpXG4gICAgfVxuICB9XG4gIHJldHVybiB7IHcsIGgsIHJnYmEgfVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBhdmVyYWdlIGNvbG9yIGZyb20gYSBUaHVtYkhhc2guIFJHQiBpcyBub3QgYmUgcHJlbXVsdGlwbGllZCBieSBBLlxuICpcbiAqIEBwYXJhbSBoYXNoIFRoZSBieXRlcyBvZiB0aGUgVGh1bWJIYXNoLlxuICogQHJldHVybnMgVGhlIFJHQkEgdmFsdWVzIGZvciB0aGUgYXZlcmFnZSBjb2xvci4gRWFjaCB2YWx1ZSByYW5nZXMgZnJvbSAwIHRvIDEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHVtYkhhc2hUb0F2ZXJhZ2VSR0JBKGhhc2gpIHtcbiAgbGV0IHsgbWluLCBtYXggfSA9IE1hdGhcbiAgbGV0IGhlYWRlciA9IGhhc2hbMF0gfCAoaGFzaFsxXSA8PCA4KSB8IChoYXNoWzJdIDw8IDE2KVxuICBsZXQgbCA9IChoZWFkZXIgJiA2MykgLyA2M1xuICBsZXQgcCA9ICgoaGVhZGVyID4+IDYpICYgNjMpIC8gMzEuNSAtIDFcbiAgbGV0IHEgPSAoKGhlYWRlciA+PiAxMikgJiA2MykgLyAzMS41IC0gMVxuICBsZXQgaGFzQWxwaGEgPSBoZWFkZXIgPj4gMjNcbiAgbGV0IGEgPSBoYXNBbHBoYSA/IChoYXNoWzVdICYgMTUpIC8gMTUgOiAxXG4gIGxldCBiID0gbCAtIDIgLyAzICogcFxuICBsZXQgciA9ICgzICogbCAtIGIgKyBxKSAvIDJcbiAgbGV0IGcgPSByIC0gcVxuICByZXR1cm4ge1xuICAgIHI6IG1heCgwLCBtaW4oMSwgcikpLFxuICAgIGc6IG1heCgwLCBtaW4oMSwgZykpLFxuICAgIGI6IG1heCgwLCBtaW4oMSwgYikpLFxuICAgIGFcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBhcHByb3hpbWF0ZSBhc3BlY3QgcmF0aW8gb2YgdGhlIG9yaWdpbmFsIGltYWdlLlxuICpcbiAqIEBwYXJhbSBoYXNoIFRoZSBieXRlcyBvZiB0aGUgVGh1bWJIYXNoLlxuICogQHJldHVybnMgVGhlIGFwcHJveGltYXRlIGFzcGVjdCByYXRpbyAoaS5lLiB3aWR0aCAvIGhlaWdodCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHVtYkhhc2hUb0FwcHJveGltYXRlQXNwZWN0UmF0aW8oaGFzaCkge1xuICBsZXQgaGVhZGVyID0gaGFzaFszXVxuICBsZXQgaGFzQWxwaGEgPSBoYXNoWzJdICYgMHg4MFxuICBsZXQgaXNMYW5kc2NhcGUgPSBoYXNoWzRdICYgMHg4MFxuICBsZXQgbHggPSBpc0xhbmRzY2FwZSA/IGhhc0FscGhhID8gNSA6IDcgOiBoZWFkZXIgJiA3XG4gIGxldCBseSA9IGlzTGFuZHNjYXBlID8gaGVhZGVyICYgNyA6IGhhc0FscGhhID8gNSA6IDdcbiAgcmV0dXJuIGx4IC8gbHlcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGFuIFJHQkEgaW1hZ2UgdG8gYSBQTkcgZGF0YSBVUkwuIFJHQiBzaG91bGQgbm90IGJlIHByZW11bHRpcGxpZWQgYnlcbiAqIEEuIFRoaXMgaXMgb3B0aW1pemVkIGZvciBzcGVlZCBhbmQgc2ltcGxpY2l0eSBhbmQgZG9lcyBub3Qgb3B0aW1pemUgZm9yIHNpemVcbiAqIGF0IGFsbC4gVGhpcyBkb2Vzbid0IGRvIGFueSBjb21wcmVzc2lvbiAoYWxsIHZhbHVlcyBhcmUgc3RvcmVkIHVuY29tcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHcgVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCBpbWFnZS4gTXVzdCBiZSDiiaQxMDBweC5cbiAqIEBwYXJhbSBoIFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IGltYWdlLiBNdXN0IGJlIOKJpDEwMHB4LlxuICogQHBhcmFtIHJnYmEgVGhlIHBpeGVscyBpbiB0aGUgaW5wdXQgaW1hZ2UsIHJvdy1ieS1yb3cuIE11c3QgaGF2ZSB3KmgqNCBlbGVtZW50cy5cbiAqIEByZXR1cm5zIEEgZGF0YSBVUkwgY29udGFpbmluZyBhIFBORyBmb3IgdGhlIGlucHV0IGltYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmdiYVRvRGF0YVVSTCh3LCBoLCByZ2JhKSB7XG4gIGxldCByb3cgPSB3ICogNCArIDFcbiAgbGV0IGlkYXQgPSA2ICsgaCAqICg1ICsgcm93KVxuICBsZXQgYnl0ZXMgPSBbXG4gICAgMTM3LCA4MCwgNzgsIDcxLCAxMywgMTAsIDI2LCAxMCwgMCwgMCwgMCwgMTMsIDczLCA3MiwgNjgsIDgyLCAwLCAwLFxuICAgIHcgPj4gOCwgdyAmIDI1NSwgMCwgMCwgaCA+PiA4LCBoICYgMjU1LCA4LCA2LCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIGlkYXQgPj4+IDI0LCAoaWRhdCA+PiAxNikgJiAyNTUsIChpZGF0ID4+IDgpICYgMjU1LCBpZGF0ICYgMjU1LFxuICAgIDczLCA2OCwgNjUsIDg0LCAxMjAsIDFcbiAgXVxuICBsZXQgdGFibGUgPSBbXG4gICAgMCwgNDk4NTM2NTQ4LCA5OTcwNzMwOTYsIDY1MTc2Nzk4MCwgMTk5NDE0NjE5MiwgMTgwMjE5NTQ0NCwgMTMwMzUzNTk2MCxcbiAgICAxMzQyNTMzOTQ4LCAtMzA2Njc0OTEyLCAtMjY3NDE0NzE2LCAtNjkwNTc2NDA4LCAtODgyNzg5NDkyLCAtMTY4Nzg5NTM3NixcbiAgICAtMjAzMjkzODI4NCwgLTE2MDk4OTk0MDAsIC0xMTExNjI1MTg4XG4gIF1cbiAgbGV0IGEgPSAxLCBiID0gMFxuICBmb3IgKGxldCB5ID0gMCwgaSA9IDAsIGVuZCA9IHJvdyAtIDE7IHkgPCBoOyB5KyssIGVuZCArPSByb3cgLSAxKSB7XG4gICAgYnl0ZXMucHVzaCh5ICsgMSA8IGggPyAwIDogMSwgcm93ICYgMjU1LCByb3cgPj4gOCwgfnJvdyAmIDI1NSwgKHJvdyA+PiA4KSBeIDI1NSwgMClcbiAgICBmb3IgKGIgPSAoYiArIGEpICUgNjU1MjE7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgbGV0IHUgPSByZ2JhW2ldICYgMjU1XG4gICAgICBieXRlcy5wdXNoKHUpXG4gICAgICBhID0gKGEgKyB1KSAlIDY1NTIxXG4gICAgICBiID0gKGIgKyBhKSAlIDY1NTIxXG4gICAgfVxuICB9XG4gIGJ5dGVzLnB1c2goXG4gICAgYiA+PiA4LCBiICYgMjU1LCBhID4+IDgsIGEgJiAyNTUsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgNzMsIDY5LCA3OCwgNjgsIDE3NCwgNjYsIDk2LCAxMzBcbiAgKVxuICBmb3IgKGxldCBbc3RhcnQsIGVuZF0gb2YgW1sxMiwgMjldLCBbMzcsIDQxICsgaWRhdF1dKSB7XG4gICAgbGV0IGMgPSB+MFxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICBjIF49IGJ5dGVzW2ldXG4gICAgICBjID0gKGMgPj4+IDQpIF4gdGFibGVbYyAmIDE1XVxuICAgICAgYyA9IChjID4+PiA0KSBeIHRhYmxlW2MgJiAxNV1cbiAgICB9XG4gICAgYyA9IH5jXG4gICAgYnl0ZXNbZW5kKytdID0gYyA+Pj4gMjRcbiAgICBieXRlc1tlbmQrK10gPSAoYyA+PiAxNikgJiAyNTVcbiAgICBieXRlc1tlbmQrK10gPSAoYyA+PiA4KSAmIDI1NVxuICAgIGJ5dGVzW2VuZCsrXSA9IGMgJiAyNTVcbiAgfVxuICByZXR1cm4gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwnICsgYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmJ5dGVzKSlcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgVGh1bWJIYXNoIHRvIGEgUE5HIGRhdGEgVVJMLiBUaGlzIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gdGhhdFxuICoganVzdCBjYWxscyBcInRodW1iSGFzaFRvUkdCQVwiIGZvbGxvd2VkIGJ5IFwicmdiYVRvRGF0YVVSTFwiLlxuICpcbiAqIEBwYXJhbSBoYXNoIFRoZSBieXRlcyBvZiB0aGUgVGh1bWJIYXNoLlxuICogQHJldHVybnMgQSBkYXRhIFVSTCBjb250YWluaW5nIGEgUE5HIGZvciB0aGUgcmVuZGVyZWQgVGh1bWJIYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGh1bWJIYXNoVG9EYXRhVVJMKGhhc2gpIHtcbiAgbGV0IGltYWdlID0gdGh1bWJIYXNoVG9SR0JBKGhhc2gpXG4gIHJldHVybiByZ2JhVG9EYXRhVVJMKGltYWdlLncsIGltYWdlLmgsIGltYWdlLnJnYmEpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/thumbhash/thumbhash.js\n");

/***/ })

};
;